* [[http://podcasts.ox.ac.uk/introduction-theory-lists][An Introduction to a Theory of Lists]]

Richard Bird
Oxford, 16th and 17th December 1986

A calculus used for deriving efficient solutions to certain kinds of problems in computation.
A set of laws, lemmas, and theorems in the same sense of integral calculus.
It does not stand for a formal systems with axioms and inference rules.
Semantic and foundational issues are not touched upon.

Theory of expression trees are waiting to be organized.

Program specification / transformation

General laws which enable programs to be calculated.

Richard Bird has been dissatisfied about the lack of penetrating results such as in integral calculus that scientists and engineers use daily.

Only two players: Richard Bird and Lambert Meertens

Dijkstra, Grieves, Backhouse program calculation with invariant assertions

Difference between Eindhoven school is that of style not of objective.

Eindhoven use imperative notation andd uses predicate calculus as the main tool and
many of the results are presented using arrays.

Bird-Meertens is: Functional notation, specialized functional calculus and considers lists as a more basic data structure than arrays.

** Summary:

First Lecture

Notation suggested by David Turner

Second Lecture

First example of a calculational proof and some further notation

Third Lecture

Problems about segments of lists

Fourth Lecture

Problems about partitions of lists

Fifth Lecture

More material and further examples

** 1 List Notation

Lists: Ordered and homogenous

[]
['a']
['a','p','p','l','e']

** 2 Convention

a, b, c â€¦ elements of lists
x, y, z â€¦ lists
xs, ys, zs â€¦ lists of lists

** 3 Length

# :: [ Î± ] -> Num
#[a1,a2,â€¦an] = n

** 4 Concatenation

++ :: [ Î± ] Ã— [ Î± ] â†’ [ Î± ]
Associativity: (x ++ y) ++ z = x ++ ( y ++ z )
Identity: x ++ [] = [] ++ x = x

# (x ++ y) = # x + # y
(#, ++ distribution)

** 5 Map
* :: ( Î± â†’ Î² ) Ã— [ Î± ] â†’ [ Î² ]

f * [ aâ‚, aâ‚‚, â€¦ , aâ‚“ ] = [ faâ‚ , faâ‚‚, â€¦ faâ‚“]

f * ( x ++ y ) = ( f * x ) ++ ( f * y )
{ *, ++ distributivity }

(f â€¢ g) * = (f * ) â€¢ ( g * )
{ *, â€¢ dist }

( f * )â»Â¹ = ( fâ»Â¹ * )
{ *, â»Â¹ comm }

** 6 Notational interlude

Let âŠ• :: ( âº âœ• Î² ) â†’ ğ›¾

(a âŠ• ) :: Î² â†’ ğ›¾ | ( a âŠ• ) b = a âŠ• b

( âŠ• b ) :: âº â†’ ğ›¾ | ( âŠ• b ) a = a âŠ• b

( f * ) f-map function
( + 1 ) successor function
( ++ [a] ) append a function

Function application is left-associative and has highest precedence

f x y + 3 = ((f x) y) + 3

** 7 Filter

â— :: ( Î± â†’ Bool ) Ã— [ âº ] â†’ [ âº ]
p â— x the sublists of elements of x satisfying p

even â— [1 .. 10] = [2, 4, 6, 8, 10]

p â— ( x ++ y) = (p â— x) ++ (p â— y)
{â—, ++ dist }

(p â— ) â€¢ (p â—) = (p â—)
{ â— idem }
(p â—) â€¢ (q â—) = (q â—) â€¢ (p â—)
{ â— comm } (For total functions)

(p â—) â€¢ (f *) = (f *) â€¢ ((p â€¢ f) â—)
{ â—, â€¢ comm }

8 Reduce

Borrowed from APL

Operator which takes an operator
/ :: ( âº Ã— âº â†’ âº) Ã— [ âº ] â†’ âº
âŠ• / [ aâ‚, aâ‚‚, â€¦ , aâ‚“ ] = aâ‚ âŠ• aâ‚‚ âŠ• â€¦ âŠ• aâ‚“
Only defined if âŠ• is associative

Laws

âŠ• / [ a ]  = a { / singletons }
âŠ• / (x ++ y) = (âŠ• / x) âŠ• (âŠ• / y) { / dist }

If âŠ• has an identity element e, then
âŠ• / [] = e
otherwise,
âŠ• / [] is not defined

âŠ• / y = âŠ• / ( [] ++ y ) = (âŠ• / [] ) âŠ• (âŠ• / y) = e âŠ• (âŠ•/y)

9 Examples

sum = + /
product = Ã— /

n! = x / [1 .. n]

flatten = ++ /

flatten [[1, 2], [], [2, 3]] = [1, 2, 2, 3]

min = â†“ /
max = â†‘ /

head = << /
last = >> /

all p = (Ë„ / ) â€¢ (p â€¢)
some p = (Ë… / ) â€¢ (p â€¢)

10 Promotion Lemmas

Generalize the distribution laws of map, filter, reduce

(f *) â€¢ (++ /) = (++ /) â€¢ ((f *) *)
{ * promotion }

fmap to a flatten list is the same as flatten map of f map map.

f*(++ / [ xâ‚, xâ‚‚, â€¦ , xâ‚“ ] = f*(xâ‚ ++ xâ‚‚ ++ â€¦ ++ xâ‚“)
= (f*xâ‚) ++ f(xâ‚‚) ++ â€¦ ++ f(xâ‚“)
= ++ / [f*xâ‚, f(xâ‚‚), â€¦ , f(xâ‚“) ]
= ++ / (f*)* [ xâ‚, xâ‚‚, â€¦ , xâ‚“ ]

Rather than flattening
Promote the map into each component list and then flatten the result

( p â— ) â€¢ (++ /) = (++ /) â€¢ ( p â— * )
{ â— promotion }

( âŠ• â— ) â€¢ (++ /) = (âŠ• /) â€¢ ( âŠ• / * )
{ âŠ• promotion }

11 Homomorphisms

A function that preserves the properties of associativity and identity e.

h [] = e
h (x ++ y) = h x âŠ• h y

Equivalently, if h â€¢ ( ++ / ) = (âŠ• / ) â€¢ (h *)

12 Homomorphism Lemma

h is a homomorphism iff
h = (âŠ• / ) â€¢ (f *) for some âŠ• and f.

Proof

Suppose h = (âŠ• / ) â€¢ (f *)
Then h â€¢ (++ /) = (âŠ• / ) â€¢ (f *) â€¢ ( ++ / )
{ hypothesis }
= (âŠ• / ) â€¢ (++ /) â€¢ ( (f *) * )
{ *-promotion }
= (âŠ• / ) â€¢ (+(âŠ• / ) *) â€¢ ( (f *) * )
{ /-promotion }
= (âŠ• / ) â€¢ (+(âŠ• / ) *) â€¢ ( (f *) * )
{ *, â€¢ dist }
= (âŠ• / ) â€¢ (h *)
{ hypothesis }

Second, define â–¡ a = [a]

so (++ /) â€¢ (â–¡ *) = id

Now h = h â€¢ (++ /) â€¢ ( â–¡ * )
{ definition of â–¡ }
= (âŠ• /) â€¢ (h *) â€¢ (â–¡ *)
{ h is a homomorphism}
= (âŠ• /) â€¢ (f *)
{ *, â€¢ dist }

where f = h â€¢ â–¡
Hence h = (âŠ• /) â€¢ (f *)
for suitable âŠ• and f.

** 13 Examples of homomorphisms

Filter is a homomorphism
(p â—) = (++ /) â€¢ (f_p *)
where f_p a = [a] if p a
= [] otherwise

# = (+ /) â€¢ (K_1 *) where K_a b = a
K is the K combinator for combinatory calculus

sort = (merge /) â€¢ (â–¡ *)

reverse = (++~ /) â€¢ (â–¡ *)
where a âŠ•~ b = b âŠ• a

** 14 Lemma

a âŠ• b = h(hâ»Â¹ a ++ hâ»Â¹ b)

Then h (x ++ y) = h x âŠ• h y

Try and solve a problem by looking for a homomorphism

** 15 Text Processing

Text = [ Char ]
Line = [ Char \ { NL } ]

unlines :: [Line]âº â†’ Text
unlines = âŠ• /
x âŠ• y = x ++ [ NL ] ++ y

lines is an injective function

lines :: Text â†’ [ Line ]
lines â€¢ unlines = id

Problem: give a constructive definition of lines

Since line is an injective function (intuitively at least)

lines = (âŠ— / ) â€¢ (f *)

Direct calculation yields:

f a = [[], []] if a = NL
= [[a]], otherwise

(xs ++ [x]) âŠ— ([y] ++ ys) = xs ++ [x ++ y] ++ ys

** 16 More text-processing

Word = [ Char \ { SP, NL ]âº
Para = [ Lineâº ]âº

unwords :: [ Word ]âº â†’ Line
unwords = âŠ•SP /
x âŠ•sp y = x ++ [ SP ] ++ y

words :: Line â†’ [ Word ]
words = (( â‰  [] ) â— ) â€¢ ( âŠ— / ) â€¢ (f_SP * )

unparas :: [ Para ]âº â†’ [ Lines ]
unparas = âŠ•[] /
x âŠ•[] y = x ++ [ [] ] ++ y

paras :: [ Line ] â†’ [ Para ]
paras = (( â‰  [] ) â— ) â€¢ ( âŠ— / ) â€¢ (f_[] * )

** 17 Examples of use

countlines = # â€¢ lines

countwords = # â€¢ (++ / ) â€¢ (words * ) â€¢ lines

countparas = # â€¢ paras â€¢ lines

normalise :: Text â†’ Text
normalize = unparse â€¢ parse

parse = ( ( words * ) * ) â€¢ paras â€¢ lines
unparse = unlines â€¢ unparas â€¢ ( ( unwords *  ) * )

Unparse is correct because

( f â€¢ g )â»Â¹ = gâ»Â¹ â€¢ fâ»Â¹
(f *)â»Â¹ = (fâ»Â¹ *)

** 20 Directed Reduction

â†/- right-reduce
-/â†’ left-reduce

(âŠ• â†/-)[ aâ‚, aâ‚‚, â€¦ , aâ‚“ ] = aâ‚ âŠ•( aâ‚‚ âŠ• â€¦ (aâ‚“âŠ•e))
The âŠ• need not be associative and doesnâ€™t need to have a unit

â†/- :: (( âº Ã— Î² â†’ Î² ) Ã— Î² ) â†’ [ âº ] â†’ Î²
-/â†’ :: (( Î² Ã— âº â†’ Î²) Ã— Î² ) â†’ [ âº ] â†’ Î²

(âŠ• -/â†’)[ aâ‚, aâ‚‚, â€¦ , aâ‚“ ] = (((eâŠ•aâ‚)âŠ• aâ‚‚) âŠ• â€¦ aâ‚“)

Why do we need more reductions? Because they are implementations of the fold function and are closer to what can be achieved by machines.

(f * ) (âŠ• â†/- [])  where a âŠ• x = [ f a ] ++ x

** 21 Duality Lemma

(âŠ• -/â†’) = (âŠ•~ â†/-) â€¢ reverse

Example: fact n = x / [ 1 â€¦ n ]
fact n = ( Ã— -/â†’ 1 ) [1 â€¦ n] "going up"

fact n = (Ã— â†/- 1) [ 1 â€¦ n ]
= ( Ã—~ -/â†’ 1) [n, n-1 â€¦ 1]
= (Ã— -/â†’ 1) [n, n-1, â€¦ 1]
"going down"

** 22 Specialization Lemma

Every homomorphism can be written as a left-reduction, or as a right reduction.

( âŠ™ / ) â€¢ ( f * ) = (âŠ• â†/- e) = (âŠ— -/â†’ e)
where
a âŠ• b = f a âŠ™ b
a âŠ— b = a âŠ™ f b

and e is the identity element of âŠ™.

** 22.5 Cons

(:) :: âº Ã— [ âº ] â†’ [ âº ]
a : x = [ a ] ++ x
x ++ y = (: â†/- y ) x

Either : or ++ can be taken as primitive, but unlike ++, every list can be expressed/constructed in terms of [] and : in exactly one way.

Cons has a canonical form, ++ has many ways in which the same thing can be expressed.

** 23 Recursive characterisation

(âŠ• â†/- e) [] = e

(âŠ• â†/- e) ( [a] ++ x ) = a âŠ• (âŠ• â†/- e) x

We can say f = (âŠ• â†/- e) is the solution of:

f [] = e
f([a] ++ x) = a âŠ• fx

Progress of computation is recursive.

Similarly,

(âŠ• -/â†’ e)[] = e
(âŠ• -/â†’ e)(x ++ [a] ) = (âŠ• -/â†’ e) x âŠ• a

But also
(âŠ• -/â†’ e) [] = e
(âŠ• -/â†’ e)([a] ++ x) = (âŠ• -/â†’ (e âŠ• a) ) x

So f = (âŠ• -/â†’ e)(âŠ• -/â†’ e) is the solution of
f x = g e x
g e [] = e
g e([a] ++ x) = g(e âŠ• a) x

So left reductions have the advantage that they give an iterative notion of programming. They are immediately expressing in terms of imperative notions:

y := (âŠ• -/â†’ e) x âŸ¹ y := e;
                    for a â† x
                    do y := y âŠ• a

** 24 Efficiency Consideration

In a functional programming language â†/- can be more time-efficient than -/â†’.
â†/- can be more space-efficient than -/â†’.

Recall a << b = a and a >> b = b
(<< â†/- e)[1, 2, 3]

(âŠ• â†/- e)([a] ++ x) = a âŠ• (âŠ• â†/- e) x
(âŠ• -/â†’ e)([a] ++ x) = (âŠ• -/â†’ (e âŠ• a)) x

(<< â†/- e)[1, 2, 3]
= 1 << (<< â†/- e)[2, 3] (â†/- .2)
= 1 (<<.1)
This can terminate after one step

(>> -/â†’ e)[3, 2, 1]
= (>> -/â†’ (e >> 3))[2, 1] (-/â†’ .2)
= (>> -/â†’ 3)[2, 1] (>>.1)
= (>> -/â†’ (3 >> 2))[1] (-/â†’ .2)
= (>> -/â†’ 2)[1] (>>.1)
= (>> -/â†’ ( 2 >> 1))[] (-/â†’ .2)
= (>> -/â†’ 1)[] (>>.1)
= 1 (-/â†’ .1)

Whole of the list must be traversed


(+ â†/- 0)[1, 2, 3]
= 1 + (+ â†/- 0)[2, 3]
= 1 + (2 + (+ â†/- 0)[3])
= 1 + (2 + (3 + (+ â†/- 0)[])
= 1 + (2 + (3 + 0))
= 6

Linear space. Same size as the list that we started with.

(+ -/â†’ 0)[1, 2, 3]
= (+ -/â†’ (0 + 1))[2, 3]
{ We can evaluate the answer now reducing the size of the list }
= (+ -/â†’ 1)[2, 3]
= (+ -/â†’ (1 + 2))[3]
= (+ -/â†’ 3)[3]
= (+ -/â†’ (3 + 3))[]
= (+ -/â†’ 6)[]
= 6
Constant space

Conclusion

Use (âŠ• -/â†’ e) when âŠ• is strict in the sense that it requires the evaluation of both arguments to return the result. Eg: + Ã— â†‘ â†“

Use (âŠ• â†/- e) when âŠ•âŠ• is non-strict that is it does not always demand the complete evaluation of both left and right arguments to return the result.

e.g. and or <<
